bit_shift.c ,  22 , '<<': shift count negative or too big, undefined behavior
bit_shift.c ,  34 , '<<': shift count negative or too big, undefined behavior
bit_shift.c ,  46 , '<<': shift count negative or too big, undefined behavior
bit_shift.c ,  58 , '<<': shift count negative or too big, undefined behavior
bit_shift.c ,  70 , '<<': shift count negative or too big, undefined behavior
bit_shift.c ,  82 , '>>': shift count negative or too big, undefined behavior
bit_shift.c ,  94 , '>>': shift count negative or too big, undefined behavior
bit_shift.c ,  237 , '<<': shift count negative or too big, undefined behavior
data_overflow.c ,  332 , constant too big
dead_lock.c ,  21 , initializer is not a constant
dead_lock.c ,  22 , initializer is not a constant
dead_lock.c ,  130 , initializer is not a constant
dead_lock.c ,  131 , initializer is not a constant
dead_lock.c ,  132 , initializer is not a constant
double_lock.c ,  26 , initializer is not a constant
double_lock.c ,  79 , initializer is not a constant
double_lock.c ,  128 , initializer is not a constant
double_lock.c ,  188 , initializer is not a constant
double_lock.c ,  196 , 'type cast': pointer truncation from 'void *' to 'long'
double_lock.c ,  210 , 'type cast': pointer truncation from 'void *' to 'long'
double_lock.c ,  224 , 'type cast': conversion from 'long' to 'void *' of greater size
double_lock.c ,  225 , 'type cast': conversion from 'long' to 'void *' of greater size
function_return_value_unchecked.c ,  187 , different array subscripts: 'float (*)[4]' and 'float (*)[0]'
func_pointer.c ,  437 , different array subscripts: 'int (*)[4]' and 'int (*)[0]'
func_pointer.c ,  454 , different array subscripts: 'int (*)[4]' and 'int (*)[0]'
func_pointer.c ,  61 , Using uninitialized memory 'buf'.: Lines: 57, 58, 60, 61
func_pointer.c ,  61 , Using uninitialized memory 'buf[BYTE:0]'.: Lines: 57, 58, 60, 61
func_pointer.c ,  103 , Buffer overrun while writing to 'str_rev':  the writable size is 'i+1' bytes, but 'i' bytes might be written.: Lines: 92, 93, 94, 95, 97, 98, 99, 101, 99, 103
func_pointer.c ,  103 , Dereferencing NULL pointer 'str_rev'. : Lines: 92, 93, 94, 95, 97, 98, 99, 103
func_pointer.c ,  151 , Dereferencing NULL pointer 'doubleptr'. : Lines: 145, 146, 147, 149, 151
func_pointer.c ,  157 , Dereferencing NULL pointer 'doubleptr[i]'. : Lines: 145, 146, 147, 149, 151, 149, 151, 149, 153, 155, 157
func_pointer.c ,  177 , Dereferencing NULL pointer 'doubleptr'. : Lines: 165, 166, 168, 170, 171, 172, 173, 175, 177
func_pointer.c ,  216 , Dereferencing NULL pointer 'doubleptr[i]'. : Lines: 205, 206, 208, 210, 208, 210, 208, 212, 214, 216
func_pointer.c ,  210 , Dereferencing NULL pointer 'doubleptr'. : Lines: 205, 206, 208, 210
func_pointer.c ,  254 , Local declaration of 'doubleptr' hides previous declaration at line '192' of 'c:\work\itc-benchmarks\01.w_defects\func_pointer.c'.: Lines: 192
func_pointer.c ,  294 , Local declaration of 'a' hides previous declaration at line '292' of 'c:\work\itc-benchmarks\01.w_defects\func_pointer.c'.: Lines: 292
func_pointer.c ,  302 , Potential comparison of a constant with another constant.
func_pointer.c ,  338 , Dereferencing NULL pointer 'u'. : Lines: 330, 331, 332, 333, 335, 337, 338
func_pointer.c ,  352 , Dereferencing NULL pointer 'p'. : Lines: 348, 349, 350, 351, 352
func_pointer.c ,  364 , Local declaration of 'a' hides previous declaration at line '292' of 'c:\work\itc-benchmarks\01.w_defects\func_pointer.c'.: Lines: 292
func_pointer.c ,  397 , Buffer overrun while writing to 'str_rev':  the writable size is 'i+1' bytes, but '2' bytes might be written.: Lines: 386, 387, 388, 389, 391, 392, 393, 395, 393, 397
func_pointer.c ,  397 , Dereferencing NULL pointer 'str_rev'. : Lines: 386, 387, 388, 389, 391, 392, 393, 397
func_pointer.c ,  413 , Potential comparison of a constant with another constant.
func_pointer.c ,  438 , 'p' could be '0':  this does not adhere to the specification for the function 'memcpy'. : Lines: 431, 432, 436, 437, 438
func_pointer.c ,  443 , Dereferencing NULL pointer 'p'. See line 438 for an earlier location where this can occur: Lines: 431, 432, 436, 437, 438, 439, 441, 443
func_pointer.c ,  465 , Local declaration of 'a' hides previous declaration at line '292' of 'c:\work\itc-benchmarks\01.w_defects\func_pointer.c'.: Lines: 292
func_pointer.c ,  483 , Local declaration of 'func_gbl' hides previous declaration at line '21' of 'c:\work\itc-benchmarks\01.w_defects\func_pointer.c'.: Lines: 21
func_pointer.c ,  496 , Local declaration of 'func_gbl' hides previous declaration at line '21' of 'c:\work\itc-benchmarks\01.w_defects\func_pointer.c'.: Lines: 21
func_pointer.c ,  510 , Local declaration of 'a' hides previous declaration at line '292' of 'c:\work\itc-benchmarks\01.w_defects\func_pointer.c'.: Lines: 292
func_pointer.c ,  601 , 'st1' could be '0':  this does not adhere to the specification for the function 'memset'. : Lines: 598, 599, 600, 601
free_null_pointer.c ,  74 , Dereferencing NULL pointer 'fptr'. : Lines: 69, 70, 74
free_null_pointer.c ,  146 , '((s+4))->buf' could be '0':  this does not adhere to the specification for the function 'strcpy'. : Lines: 136, 137, 138, 140, 142, 144, 142, 144, 142, 146
free_null_pointer.c ,  146 , Dereferencing NULL pointer 's+4'. See line 144 for an earlier location where this can occur: Lines: 136, 137, 138, 140, 142, 144, 142, 144, 142, 146
free_null_pointer.c ,  151 , Using uninitialized memory '**s[BYTE:8]'.: Lines: 136, 137, 138, 140, 148, 150, 151, 150, 151
free_null_pointer.c ,  151 , Dereferencing NULL pointer 's+i'. : Lines: 136, 137, 138, 140, 148, 150, 151
free_null_pointer.c ,  177 , Dereferencing NULL pointer 'free_null_pointer_007_gbl_doubleptr'. : Lines: 172, 173, 175, 177
free_null_pointer.c ,  183 , Dereferencing NULL pointer 'free_null_pointer_007_gbl_doubleptr[i]'. : Lines: 172, 173, 175, 177, 175, 177, 175, 179, 181, 183
free_null_pointer.c ,  335 , Potential comparison of a constant with another constant.
free_null_pointer.c ,  440 , Local declaration of 'a' hides previous declaration at line '96' of 'c:\work\itc-benchmarks\01.w_defects\free_null_pointer.c'.: Lines: 96
free_null_pointer.c ,  443 , (<expression> && <non-zero constant>) always evaluates to the result of <expression>.  Did you intend to use the bitwise-and operator?
free_null_pointer.c ,  449 , (<expression> && <non-zero constant>) always evaluates to the result of <expression>.  Did you intend to use the bitwise-and operator?
free_null_pointer.c ,  455 , (<expression> && <non-zero constant>) always evaluates to the result of <expression>.  Did you intend to use the bitwise-and operator?
free_null_pointer.c ,  443 , Potential comparison of a constant with another constant.
free_null_pointer.c ,  449 , Potential comparison of a constant with another constant.
free_null_pointer.c ,  455 , Potential comparison of a constant with another constant.
free_null_pointer.c ,  452 , Dereferencing NULL pointer 'ptr+1'. : Lines: 440, 441, 443, 449, 451, 452
free_null_pointer.c ,  478 , Local declaration of 'fptr' hides declaration of the same name in outer scope. For additional information, see previous declaration at line '471' of 'c:\work\itc-benchmarks\01.w_defects\free_null_pointer.c'.: Lines: 471
free_null_pointer.c ,  489 , Local declaration of 'fptr' hides declaration of the same name in outer scope. For additional information, see previous declaration at line '471' of 'c:\work\itc-benchmarks\01.w_defects\free_null_pointer.c'.: Lines: 471
free_null_pointer.c ,  483 , Dereferencing NULL pointer 'fptr+3'. : Lines: 471, 472, 473, 474, 475, 478, 479, 483
free_null_pointer.c ,  512 , Ill-defined for-loop:  initial condition does not satisfy test.  Loop body not executed.
free_null_pointer.c ,  542 , Ill-defined for-loop:  initial condition does not satisfy test.  Loop body not executed.
free_nondynamically_allocated_memory.c ,  82 , Dereferencing NULL pointer '((*pbuf[i]))+j'. : Lines: 72, 73, 74, 75, 76, 80, 82, 80, 82
free_nondynamically_allocated_memory.c ,  128 , Using uninitialized memory 'ptr'.: Lines: 125, 126, 127, 128, 127, 128
free_nondynamically_allocated_memory.c ,  141 , Using uninitialized memory 'ptr'.: Lines: 138, 139, 140, 141, 140, 141
free_nondynamically_allocated_memory.c ,  208 , Dereferencing NULL pointer 'new_struct'. : Lines: 206, 207, 208
double_release.c ,  15 , Inconsistent annotation for 'rand': this instance has no annotations. See c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdlib.h(347). 
double_free.c ,  22 , Using uninitialized memory 'ptr'.: Lines: 19, 20, 22
double_free.c ,  37 , Dereferencing NULL pointer 'ptr'. : Lines: 32, 33, 35, 37
double_free.c ,  58 , Dereferencing NULL pointer 'ptr+i'. : Lines: 53, 54, 56, 58
double_free.c ,  78 , Dereferencing NULL pointer 'ptr+i'. : Lines: 74, 75, 76, 78
double_free.c ,  87 , Using uninitialized memory 'ptr'.: Lines: 74, 75, 76, 78, 76, 78, 76, 81, 83, 86, 87
double_free.c ,  100 , Using uninitialized memory 'ptr'.: Lines: 97, 98, 100
double_free.c ,  115 , Using uninitialized memory 'ptr'.: Lines: 111, 112, 113, 115
double_free.c ,  131 , Using uninitialized memory 'ptr'.: Lines: 125, 126, 128, 129, 131
double_free.c ,  168 , Using uninitialized memory 'ptr'.: Lines: 160, 161, 163, 165, 166, 163, 168
double_free.c ,  187 , Using uninitialized memory 'ptr'.: Lines: 179, 180, 182, 184, 185, 182, 187
double_free.c ,  204 , Using uninitialized memory 'ptr'.: Lines: 198, 199, 201, 203, 204, 205, 201, 203, 204
double_free.c ,  222 , Using uninitialized memory 'ptr'.: Lines: 217, 218, 220, 222, 220, 222
deletion_of_data_structure_sentinel.c ,  26 , Dereferencing NULL pointer 'foo'. : Lines: 21, 22, 23, 24, 26
dead_code.c ,  132 , Ill-defined for-loop:  initial condition does not satisfy test.  Loop body not executed.
conflicting_cond.c ,  11 , Inconsistent annotation for 'rand': this instance has no annotations. See c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdlib.h(347). 
conflicting_cond.c ,  24 , Incorrect operator:  mutual inclusion over && is always zero.  Did you intend to use || instead?
conflicting_cond.c ,  103 , Incorrect operator:  mutual inclusion over && is always zero.  Did you intend to use || instead?
conflicting_cond.c ,  118 , Incorrect operator:  mutual inclusion over && is always zero.  Did you intend to use || instead?
conflicting_cond.c ,  137 , Incorrect operator:  mutual inclusion over && is always zero.  Did you intend to use || instead?
conflicting_cond.c ,  199 , Incorrect operator:  mutual inclusion over && is always zero.  Did you intend to use || instead?
buffer_underrun_dynamic.c ,  29 , Index '-1' is out of valid index range '0' to '4' for non-stack buffer 'buf'.
buffer_underrun_dynamic.c ,  65 , Index '-1' is out of valid index range '0' to '4' for non-stack buffer 'buf'.
buffer_underrun_dynamic.c ,  97 , Index '-1' is out of valid index range '0' to '4' for non-stack buffer 'buf'.
buffer_underrun_dynamic.c ,  115 , Index '-1' is out of valid index range '0' to '4' for non-stack buffer 'buf'.
buffer_underrun_dynamic.c ,  133 , Index '-1' is out of valid index range '0' to '4' for non-stack buffer 'buf'.
buffer_underrun_dynamic.c ,  149 , Dereferencing NULL pointer 'buf'. : Lines: 145, 146, 148, 149
buffer_underrun_dynamic.c ,  178 , Index '-3' is out of valid index range '0' to '4' for possibly stack allocated buffer 'pbuf'.
buffer_underrun_dynamic.c ,  178 , Reading invalid data from 'pbuf':  the readable size is '40' bytes, but '-24' bytes may be read.: Lines: 169, 170, 171, 172, 173, 174, 175, 176, 178
buffer_underrun_dynamic.c ,  202 , Index '-1' is out of valid index range '0' to '4' for non-stack buffer 'sbuf'.
buffer_underrun_dynamic.c ,  466 , Index '-1' is out of valid index range '0' to '4' for non-stack buffer 'buf'.
buffer_underrun_dynamic.c ,  519 , Dereferencing NULL pointer 'buf2-*(buf1+4)'. : Lines: 511, 512, 513, 515, 517, 515, 517, 515, 519
buffer_underrun_dynamic.c ,  519 , Dereferencing NULL pointer 'buf1+4'. See line 517 for an earlier location where this can occur: Lines: 511, 512, 513, 515, 517, 515, 517, 515, 519
buffer_underrun_dynamic.c ,  517 , Dereferencing NULL pointer 'buf1+i'. : Lines: 511, 512, 513, 515, 517
buffer_underrun_dynamic.c ,  532 , Index '-1' is out of valid index range '0' to '0' for non-stack buffer 'buf'.
buffer_underrun_dynamic.c ,  559 , Dereferencing NULL pointer 'doubleptr[i]'. : Lines: 546, 547, 549, 551, 549, 551, 549, 555, 557, 559
buffer_underrun_dynamic.c ,  551 , Dereferencing NULL pointer 'doubleptr'. : Lines: 546, 547, 549, 551
buffer_underrun_dynamic.c ,  580 , Index '-1' is out of valid index range '0' to '11' for non-stack buffer 'ptr1'.
buffer_underrun_dynamic.c ,  606 , Index '-1' is out of valid index range '0' to '9' for non-stack buffer 'ptr_s'.
buffer_underrun_dynamic.c ,  606 , Buffer overrun while writing to 'ptr_s[i].arr':  the writable size is '10' bytes, but '-1' bytes might be written.: Lines: 600, 601, 603, 605, 606
buffer_underrun_dynamic.c ,  669 , Dereferencing NULL pointer 'doubleptr'. : Lines: 665, 666, 668, 669
buffer_underrun_dynamic.c ,  679 , Dereferencing NULL pointer 'doubleptr[0]'. : Lines: 665, 666, 668, 669, 668, 669, 668, 671, 672, 674, 676, 677, 679
buffer_underrun_dynamic.c ,  701 , Index '-10' is out of valid index range '0' to '9' for non-stack buffer 'newTest'.
buffer_overrun_dynamic.c ,  27 , Index '5' is out of valid index range '0' to '4' for non-stack buffer 'buf'.
buffer_overrun_dynamic.c ,  62 , Index '5' is out of valid index range '0' to '4' for non-stack buffer 'buf'.
buffer_overrun_dynamic.c ,  62 , Reading invalid data from 'buf':  the readable size is '20' bytes, but '24' bytes may be read.: Lines: 53, 54, 55, 56, 58, 60, 58, 60, 58, 62
buffer_overrun_dynamic.c ,  94 , Index '5' is out of valid index range '0' to '4' for non-stack buffer 'buf'.
buffer_overrun_dynamic.c ,  112 , Index '5' is out of valid index range '0' to '4' for non-stack buffer 'buf'.
buffer_overrun_dynamic.c ,  130 , Index '5' is out of valid index range '0' to '4' for non-stack buffer 'buf'.
buffer_overrun_dynamic.c ,  146 , Dereferencing NULL pointer 'buf'. : Lines: 142, 143, 145, 146
buffer_overrun_dynamic.c ,  152 , Dereferencing NULL pointer 'buf+i'. See line 146 for an earlier location where this can occur: Lines: 142, 143, 145, 146, 145, 146, 145, 148, 150, 152
buffer_overrun_dynamic.c ,  174 , Dereferencing NULL pointer '((*pbuf[i]))+j'. : Lines: 165, 166, 167, 168, 169, 170, 171, 172, 174, 172, 174
buffer_overrun_dynamic.c ,  198 , Index '5' is out of valid index range '0' to '4' for non-stack buffer 'sbuf'.
buffer_overrun_dynamic.c ,  198 , Buffer overrun while writing to 'sbuf':  the writable size is '60' bytes, but '72' bytes might be written.: Lines: 195, 196, 198
buffer_overrun_dynamic.c ,  248 , Buffer overrun while writing to 'buf':  the writable size is '20' bytes, but '24' bytes might be written.: Lines: 244, 245, 246, 248
buffer_overrun_dynamic.c ,  278 , Buffer overrun while writing to 'buf':  the writable size is '20' bytes, but '24' bytes might be written.: Lines: 274, 275, 276, 278
buffer_overrun_dynamic.c ,  333 , Reading invalid data from 'indexes':  the readable size is '16' bytes, but '20' bytes may be read.: Lines: 328, 329, 330, 331, 333
buffer_overrun_dynamic.c ,  350 , Buffer overrun while writing to 'buf':  the writable size is '20' bytes, but '24' bytes might be written.: Lines: 344, 345, 346, 347, 348, 350
buffer_overrun_dynamic.c ,  369 , Buffer overrun while writing to 'buf':  the writable size is '20' bytes, but '24' bytes might be written.: Lines: 361, 362, 363, 364, 365, 366, 367, 369
buffer_overrun_dynamic.c ,  462 , Index '5' is out of valid index range '0' to '4' for non-stack buffer 'buf'.
buffer_overrun_dynamic.c ,  512 , Dereferencing NULL pointer 'buf1+i'. : Lines: 507, 508, 509, 510, 512
buffer_overrun_dynamic.c ,  514 , Dereferencing NULL pointer 'buf2+*(buf1+5)'. : Lines: 507, 508, 509, 510, 512, 510, 512, 510, 514
buffer_overrun_dynamic.c ,  514 , Dereferencing NULL pointer 'buf1+5'. See line 512 for an earlier location where this can occur: Lines: 507, 508, 509, 510, 512, 510, 512, 510, 514
buffer_overrun_dynamic.c ,  532 , Buffer overrun while writing to 'buf':  the writable size is '1' bytes, but '3' bytes might be written.: Lines: 526, 527, 529, 530, 532
buffer_overrun_dynamic.c ,  551 , Dereferencing NULL pointer 'doubleptr'. : Lines: 546, 547, 549, 551
buffer_overrun_dynamic.c ,  559 , Dereferencing NULL pointer 'doubleptr[i]'. : Lines: 546, 547, 549, 551, 549, 551, 549, 555, 557, 559
buffer_overrun_dynamic.c ,  580 , Index '12' is out of valid index range '0' to '11' for non-stack buffer 'ptr1'.
buffer_overrun_dynamic.c ,  607 , Index '10' is out of valid index range '0' to '9' for non-stack buffer 'ptr_s'.
bit_shift.c ,  12 , Inconsistent annotation for 'rand': this instance has no annotations. See c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdlib.h(347). 
invalid_memory_access.c ,  33 , ':': 'int *' differs in levels of indirection from 'int'
lock_never_unlock.c ,  27 , initializer is not a constant
lock_never_unlock.c ,  78 , initializer is not a constant
lock_never_unlock.c ,  135 , initializer is not a constant
lock_never_unlock.c ,  200 , initializer is not a constant
lock_never_unlock.c ,  201 , initializer is not a constant
lock_never_unlock.c ,  208 , 'type cast': pointer truncation from 'void *' to 'long'
lock_never_unlock.c ,  227 , 'type cast': pointer truncation from 'void *' to 'long'
lock_never_unlock.c ,  244 , 'type cast': conversion from 'long' to 'void *' of greater size
lock_never_unlock.c ,  245 , 'type cast': conversion from 'long' to 'void *' of greater size
lock_never_unlock.c ,  254 , initializer is not a constant
lock_never_unlock.c ,  295 , initializer is not a constant
lock_never_unlock.c ,  296 , initializer is not a constant
lock_never_unlock.c ,  305 , 'type cast': pointer truncation from 'void *' to 'long'
lock_never_unlock.c ,  324 , 'type cast': pointer truncation from 'void *' to 'long'
lock_never_unlock.c ,  348 , 'type cast': conversion from 'long' to 'void *' of greater size
lock_never_unlock.c ,  349 , 'type cast': conversion from 'long' to 'void *' of greater size
lock_never_unlock.c ,  359 , initializer is not a constant
lock_never_unlock.c ,  360 , initializer is not a constant
lock_never_unlock.c ,  367 , 'type cast': pointer truncation from 'void *' to 'long'
lock_never_unlock.c ,  392 , 'type cast': pointer truncation from 'void *' to 'long'
lock_never_unlock.c ,  421 , 'type cast': conversion from 'long' to 'void *' of greater size
lock_never_unlock.c ,  422 , 'type cast': conversion from 'long' to 'void *' of greater size
lock_never_unlock.c ,  432 , initializer is not a constant
lock_never_unlock.c ,  433 , initializer is not a constant
lock_never_unlock.c ,  445 , 'type cast': pointer truncation from 'void *' to 'long'
lock_never_unlock.c ,  469 , 'type cast': pointer truncation from 'void *' to 'long'
lock_never_unlock.c ,  501 , 'type cast': conversion from 'long' to 'void *' of greater size
lock_never_unlock.c ,  502 , 'type cast': conversion from 'long' to 'void *' of greater size
lock_never_unlock.c ,  513 , initializer is not a constant
lock_never_unlock.c ,  514 , initializer is not a constant
lock_never_unlock.c ,  521 , 'type cast': pointer truncation from 'void *' to 'long'
lock_never_unlock.c ,  545 , 'type cast': pointer truncation from 'void *' to 'long'
lock_never_unlock.c ,  574 , 'type cast': conversion from 'long' to 'void *' of greater size
lock_never_unlock.c ,  575 , 'type cast': conversion from 'long' to 'void *' of greater size
memory_allocation_failure.c ,  532 , different array subscripts: 'int (*)[4]' and 'int (*)[0]'
race_condition.c ,  37 , 'void *(__cdecl *)()' differs in parameter lists from 'void *(__cdecl *)(void *)'
race_condition.c ,  38 , 'void *(__cdecl *)()' differs in parameter lists from 'void *(__cdecl *)(void *)'
race_condition.c ,  39 , 'void *(__cdecl *)()' differs in parameter lists from 'void *(__cdecl *)(void *)'
race_condition.c ,  40 , 'void *(__cdecl *)()' differs in parameter lists from 'void *(__cdecl *)(void *)'
race_condition.c ,  74 , 'void *(__cdecl *)()' differs in parameter lists from 'void *(__cdecl *)(void *)'
race_condition.c ,  75 , 'void *(__cdecl *)()' differs in parameter lists from 'void *(__cdecl *)(void *)'
race_condition.c ,  104 , 'void *(__cdecl *)()' differs in parameter lists from 'void *(__cdecl *)(void *)'
race_condition.c ,  105 , 'void *(__cdecl *)()' differs in parameter lists from 'void *(__cdecl *)(void *)'
race_condition.c ,  106 , 'void *(__cdecl *)()' differs in parameter lists from 'void *(__cdecl *)(void *)'
race_condition.c ,  150 , initializer is not a constant
race_condition.c ,  237 , initializer is not a constant
race_condition.c ,  295 , initializer is not a constant
race_condition.c ,  362 , initializer is not a constant
race_condition.c ,  363 , initializer is not a constant
race_condition.c ,  371 , 'type cast': pointer truncation from 'void *' to 'long'
race_condition.c ,  391 , 'type cast': pointer truncation from 'void *' to 'long'
sign_conv.c ,  13 , Inconsistent annotation for 'rand': this instance has no annotations. See c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdlib.h(347). 
redundant_cond.c ,  13 , Inconsistent annotation for 'rand': this instance has no annotations. See c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdlib.h(347). 
pow_related_errors.c ,  154 , Dereferencing NULL pointer 'newarr'. : Lines: 148, 149, 150, 151, 152, 154
pow_related_errors.c ,  155 , Dereferencing NULL pointer 'ptr_newarr'. : Lines: 148, 149, 150, 151, 152, 154, 155
overrun_st.c ,  12 , Inconsistent annotation for 'rand': this instance has no annotations. See c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdlib.h(347). 
overrun_st.c ,  21 , Index '5' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
overrun_st.c ,  21 , Buffer overrun while writing to 'buf':  the writable size is '5' bytes, but '6' bytes might be written.: Lines: 20, 21
overrun_st.c ,  32 , Index '5' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
overrun_st.c ,  32 , Buffer overrun while writing to 'buf':  the writable size is '10' bytes, but '12' bytes might be written.: Lines: 31, 32
overrun_st.c ,  44 , Index '5' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
overrun_st.c ,  44 , Reading invalid data from 'buf':  the readable size is '20' bytes, but '24' bytes may be read.: Lines: 42, 43, 44
overrun_st.c ,  55 , Index '5' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
overrun_st.c ,  55 , Buffer overrun while writing to 'buf':  the writable size is '20' bytes, but '24' bytes might be written.: Lines: 54, 55
overrun_st.c ,  66 , Index '5' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
overrun_st.c ,  66 , Buffer overrun while writing to 'buf':  the writable size is '20' bytes, but '24' bytes might be written.: Lines: 65, 66
overrun_st.c ,  77 , Index '5' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
overrun_st.c ,  77 , Buffer overrun while writing to 'buf':  the writable size is '20' bytes, but '24' bytes might be written.: Lines: 76, 77
overrun_st.c ,  88 , Index '5' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
overrun_st.c ,  88 , Buffer overrun while writing to 'buf':  the writable size is '40' bytes, but '48' bytes might be written.: Lines: 87, 88
overrun_st.c ,  99 , Index '5' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
overrun_st.c ,  99 , Buffer overrun while writing to 'buf':  the writable size is '120' bytes, but '144' bytes might be written.: Lines: 98, 99
overrun_st.c ,  110 , Index '5' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
overrun_st.c ,  110 , Buffer overrun while writing to 'buf':  the writable size is '840' bytes, but '1008' bytes might be written.: Lines: 109, 110
overrun_st.c ,  142 , Index '5' is out of valid index range '0' to '4' for possibly stack allocated buffer 'sbuf'.
overrun_st.c ,  142 , Buffer overrun while writing to 'sbuf':  the writable size is '60' bytes, but '72' bytes might be written.: Lines: 141, 142
overrun_st.c ,  158 , Index '5' is out of valid index range '0' to '4' for non-stack buffer 'overrun_st_012_s_gbl.buf'.
overrun_st.c ,  158 , Buffer overrun while writing to 'overrun_st_012_s_gbl.buf':  the writable size is '20' bytes, but '24' bytes might be written.: Lines: 158
overrun_st.c ,  169 , Buffer overrun while writing to 'buf':  the writable size is '20' bytes, but '24' bytes might be written.: Lines: 167, 168, 169
overrun_st.c ,  194 , Buffer overrun while writing to 'buf':  the writable size is '20' bytes, but '24' bytes might be written.: Lines: 192, 193, 194
overrun_st.c ,  206 , Buffer overrun while writing to 'buf':  the writable size is '20' bytes, but '24' bytes might be written.: Lines: 204, 205, 206
overrun_st.c ,  250 , Buffer overrun while writing to 'buf':  the writable size is '20' bytes, but '24' bytes might be written.: Lines: 247, 248, 249, 250
overrun_st.c ,  264 , Buffer overrun while writing to 'buf':  the writable size is '20' bytes, but '24' bytes might be written.: Lines: 260, 261, 262, 263, 264
overrun_st.c ,  280 , Buffer overrun while writing to 'buf':  the writable size is '20' bytes, but '24' bytes might be written.: Lines: 274, 275, 276, 277, 278, 279, 280
overrun_st.c ,  570 , Index '5' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
overrun_st.c ,  588 , Index '5' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
overrun_st.c ,  706 , Index '5' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
overrun_st.c ,  706 , Buffer overrun while writing to 'buf':  the writable size is '20' bytes, but '24' bytes might be written.: Lines: 705, 706
overrun_st.c ,  724 , Index '5' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
overrun_st.c ,  724 , Buffer overrun while writing to 'buf':  the writable size is '120' bytes, but '144' bytes might be written.: Lines: 716, 724
overrun_st.c ,  749 , Index '5' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
overrun_st.c ,  749 , Buffer overrun while writing to 'buf':  the writable size is '5' bytes, but '6' bytes might be written.: Lines: 748, 749
null_pointer.c ,  14 , Inconsistent annotation for 'rand': this instance has no annotations. See c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdlib.h(347). 
null_pointer.c ,  23 , Dereferencing NULL pointer 'p'. : Lines: 22, 23
null_pointer.c ,  34 , Dereferencing NULL pointer 'p'. : Lines: 32, 33, 34
null_pointer.c ,  47 , Dereferencing NULL pointer '*pp'. : Lines: 44, 45, 46, 47
null_pointer.c ,  63 , Dereferencing NULL pointer 'p'. : Lines: 62, 63
null_pointer.c ,  94 , Dereferencing NULL pointer 'p'. : Lines: 93, 94
null_pointer.c ,  117 , Dereferencing NULL pointer 'p'. : Lines: 114, 115, 116, 117
null_pointer.c ,  159 , Dereferencing NULL pointer 'p1'. : Lines: 156, 157, 158, 159
null_pointer.c ,  173 , Dereferencing NULL pointer 'p2'. : Lines: 168, 169, 170, 171, 172, 173
null_pointer.c ,  180 , Dereferencing NULL pointer 'p'. : Lines: 179, 180
null_pointer.c ,  196 , Dereferencing NULL pointer 'p'. : Lines: 190, 191, 192, 196
null_pointer.c ,  264 , Dereferencing NULL pointer 'null_pointer_016_gbl_doubleptr'. : Lines: 259, 260, 262, 264
null_pointer.c ,  270 , Dereferencing NULL pointer 'null_pointer_016_gbl_doubleptr[i]'. : Lines: 259, 260, 262, 264, 262, 264, 262, 266, 268, 270
null_pointer.c ,  321 , Dereferencing NULL pointer 'null_pointer_017dst'. : Lines: 313, 314, 316, 318, 319, 321
not_return.c ,  12 , Inconsistent annotation for 'rand': this instance has no annotations. See c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdlib.h(347). 
memory_leak.c ,  13 , Inconsistent annotation for 'rand': this instance has no annotations. See c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdlib.h(347). 
memory_leak.c ,  46 , Dereferencing NULL pointer 'ptr'. : Lines: 42, 43, 45, 46
memory_leak.c ,  52 , Dereferencing NULL pointer 'ptr+i'. See line 46 for an earlier location where this can occur: Lines: 42, 43, 45, 46, 45, 46, 45, 48, 50, 52
memory_leak.c ,  96 , '((s+4))->buf' could be '0':  this does not adhere to the specification for the function 'strcpy'. : Lines: 88, 89, 90, 91, 92, 94, 92, 94, 92, 96
memory_leak.c ,  96 , Dereferencing NULL pointer 's+4'. : Lines: 88, 89, 90, 91, 96
memory_leak.c ,  150 , Using uninitialized memory 'dptr'.: Lines: 138, 139, 141, 149, 150
memory_leak.c ,  249 , Dereferencing NULL pointer 'p2+4'. : Lines: 244, 245, 246, 247, 248, 249
memory_leak.c ,  274 , Local declaration of 'buf' hides declaration of the same name in outer scope. For additional information, see previous declaration at line '265' of 'c:\work\itc-benchmarks\01.w_defects\memory_leak.c'.: Lines: 265
memory_leak.c ,  276 , Using uninitialized memory 'un'.: Lines: 265, 266, 267, 268, 274, 276
memory_leak.c ,  311 , Dereferencing NULL pointer 'p'. : Lines: 307, 308, 309, 311
memory_leak.c ,  349 , Dereferencing NULL pointer 'p'. : Lines: 343, 344, 346, 348, 349
memory_leak.c ,  354 , Dereferencing NULL pointer 'p->s1'. : Lines: 343, 344, 346, 348, 349, 351, 353, 354
memory_leak.c ,  372 , Local declaration of 'fptr' hides declaration of the same name in outer scope. For additional information, see previous declaration at line '367' of 'c:\work\itc-benchmarks\01.w_defects\memory_leak.c'.: Lines: 367
memory_leak.c ,  449 , Dereferencing NULL pointer 'memory_leak_0017_gbl_doubleptr'. : Lines: 444, 445, 447, 449
memory_leak.c ,  455 , Dereferencing NULL pointer 'memory_leak_0017_gbl_doubleptr[i]'. : Lines: 444, 445, 447, 449, 447, 449, 447, 451, 453, 455
memory_leak.c ,  504 , Dereferencing NULL pointer 'memory_leak_0018dst'. : Lines: 496, 497, 499, 501, 502, 504
memory_allocation_failure.c ,  82 , Dereferencing NULL pointer 'ptr+i'. : Lines: 72, 73, 74, 78, 80, 82
memory_allocation_failure.c ,  84 , Dereferencing NULL pointer 'ptr'. See line 82 for an earlier location where this can occur: Lines: 72, 73, 74, 78, 80, 82, 80, 82, 80, 84
memory_allocation_failure.c ,  182 , Dereferencing NULL pointer 'memory_allocation_failure_006_gbl_doubleptr'. : Lines: 175, 177, 179, 180, 182
memory_allocation_failure.c ,  183 , Dereferencing NULL pointer 'memory_allocation_failure_006_gbl_doubleptr[i]'. : Lines: 175, 177, 179, 180, 182, 183
memory_allocation_failure.c ,  225 , Buffer overrun while writing to 'memory_allocation_failure_007_str_gbl':  the writable size is 'static_var+1' bytes, but 'static_var' bytes might be written.: Lines: 218, 219, 220, 221, 222, 223, 222, 225
memory_allocation_failure.c ,  256 , Ill-defined for-loop:  initial condition does not satisfy test.  Loop body not executed.
memory_allocation_failure.c ,  287 , Local declaration of 'vptr' hides previous declaration at line '116' of 'c:\work\itc-benchmarks\01.w_defects\memory_allocation_failure.c'.: Lines: 116
memory_allocation_failure.c ,  387 , Dereferencing NULL pointer 'memory_allocation_failure_011_gbl_u1->s1'. : Lines: 385, 386, 387
memory_allocation_failure.c ,  386 , Dereferencing NULL pointer 'memory_allocation_failure_011_gbl_u1'. : Lines: 385, 386
memory_allocation_failure.c ,  433 , Dereferencing NULL pointer 'pbuf[1]'. : Lines: 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433
memory_allocation_failure.c ,  495 , 'dptr[1]' could be '0':  this does not adhere to the specification for the function 'strcpy'. : Lines: 471, 472, 473, 476, 482, 483, 485, 487, 485, 487, 485, 492, 495
memory_allocation_failure.c ,  495 , Buffer overrun while writing to 'dptr[1]':  the writable size is 'memory_allocation_failure_013_func_001(0)*sizeof(char)' bytes, but '12' bytes might be written.: Lines: 471, 472, 473, 476, 482, 483, 485, 487, 485, 487, 485, 492, 495
memory_allocation_failure.c ,  514 , Using uninitialized memory 'a'.: Lines: 471, 472, 473, 476, 478, 492, 493, 497, 498, 502, 504, 505, 514
memory_allocation_failure.c ,  493 , Dereferencing NULL pointer 'ptr+1'. : Lines: 471, 472, 473, 476, 478, 492, 493
memory_allocation_failure.c ,  487 , Dereferencing NULL pointer 'dptr'. : Lines: 471, 472, 473, 476, 482, 483, 485, 487
memory_allocation_failure.c ,  500 , Reading invalid data from 'dptr[1]':  the readable size is 'memory_allocation_failure_013_func_001(0)*sizeof(char)' bytes, but '2' bytes may be read.: Lines: 471, 472, 473, 476, 482, 483, 485, 487, 485, 487, 485, 492, 495, 497, 500
memory_allocation_failure.c ,  500 , Dereferencing NULL pointer 'dptr[1]'. See line 495 for an earlier location where this can occur: Lines: 471, 472, 473, 476, 482, 483, 485, 487, 485, 487, 485, 492, 495, 497, 500
memory_allocation_failure.c ,  535 , Buffer overrun while writing to 'p':  the writable size is 'arr_value[1]*1' bytes, but '64' bytes might be written.: Lines: 526, 527, 531, 532, 533, 535
memory_allocation_failure.c ,  553 , Local declaration of 'staticflag' hides previous declaration at line '458' of 'c:\work\itc-benchmarks\01.w_defects\memory_allocation_failure.c'.: Lines: 458
memory_allocation_failure.c ,  577 , 'dptr[1]' could be '0':  this does not adhere to the specification for the function 'strcpy'. : Lines: 549, 550, 551, 552, 553, 554, 560, 561, 563, 565, 563, 565, 563, 567, 571, 577
memory_allocation_failure.c ,  565 , Dereferencing NULL pointer 'dptr'. : Lines: 549, 550, 551, 552, 553, 554, 560, 561, 563, 565
memory_allocation_failure.c ,  577 , Buffer overrun while writing to 'dptr[1]':  the writable size is '10' bytes, but '12' bytes might be written.: Lines: 549, 550, 551, 552, 553, 554, 560, 561, 563, 565, 563, 565, 563, 567, 571, 577
memory_allocation_failure.c ,  573 , Dereferencing NULL pointer 'ptr+1'. : Lines: 549, 550, 551, 552, 553, 554, 556, 571, 573
memory_allocation_failure.c ,  619 , Using uninitialized memory 'b'.: Lines: 549, 550, 551, 552, 553, 554, 560, 561, 563, 565, 563, 565, 563, 567, 571, 577, 578, 580, 582, 584, 582, 584, 582, 580, 582, 580, 592, 598, 600, 604, 611, 612, 611, 612, 611, 613, 614, 616, 619
memory_allocation_failure.c ,  707 , Dereferencing NULL pointer 'ptr1+1'. : Lines: 705, 706, 707
invalid_memory_access.c ,  45 , Using uninitialized memory 'ptr'.: Lines: 30, 31, 33, 35, 37, 39, 41, 44, 45
invalid_memory_access.c ,  45 , Dereferencing NULL pointer 'ptr+1'. : Lines: 30, 31, 33, 35, 44, 45
invalid_memory_access.c ,  67 , Dereferencing NULL pointer 'dptr+1'. : Lines: 57, 58, 59, 62, 64, 67
invalid_memory_access.c ,  84 , Using uninitialized memory 'dptr'.: Lines: 57, 58, 59, 62, 64, 67, 69, 76, 79, 84
invalid_memory_access.c ,  85 , Using uninitialized memory 'a'.: Lines: 57, 58, 59, 60, 64, 65, 69, 72, 79, 85
invalid_memory_access.c ,  105 , Using uninitialized memory 'buf'.: Lines: 95, 96, 97, 99, 100, 102, 103, 105
invalid_memory_access.c ,  147 , Using uninitialized memory 'ptr'.: Lines: 143, 145, 147
invalid_memory_access.c ,  181 , Dereferencing NULL pointer '((*pbuf[i]))+j'. : Lines: 168, 169, 170, 171, 172, 173, 174, 175, 179, 181, 179, 181
invalid_memory_access.c ,  188 , Using uninitialized memory 'buf2'.: Lines: 168, 169, 170, 171, 172, 173, 174, 175, 177, 179, 181, 179, 181, 179, 183, 184, 185, 186, 187, 188
invalid_memory_access.c ,  188 , Using uninitialized memory '*buf2'.: Lines: 168, 169, 170, 171, 172, 173, 174, 175, 177, 179, 181, 179, 181, 179, 183, 184, 185, 186, 187, 188
invalid_memory_access.c ,  188 , Dereferencing NULL pointer 'buf2'. See line 181 for an earlier location where this can occur: Lines: 168, 169, 170, 171, 172, 173, 174, 175, 179, 181, 179, 181, 179, 183, 184, 185, 186, 187, 188
invalid_memory_access.c ,  201 , Dereferencing NULL pointer 'ptr'. : Lines: 197, 198, 200, 201
invalid_memory_access.c ,  205 , Dereferencing NULL pointer 'ptr+i'. See line 201 for an earlier location where this can occur: Lines: 197, 198, 200, 201, 200, 201, 200, 203, 205
invalid_memory_access.c ,  210 , Using uninitialized memory 'ptr'.: Lines: 197, 198, 200, 201, 200, 201, 200, 203, 205, 206, 207, 203, 205, 206, 207, 203, 209, 210
invalid_memory_access.c ,  224 , Using uninitialized memory 'buf'.: Lines: 219, 220, 221, 223, 224
invalid_memory_access.c ,  265 , Dereferencing NULL pointer 'p->s1->a'. : Lines: 255, 256, 258, 260, 261, 262, 264, 265
invalid_memory_access.c ,  265 , Dereferencing NULL pointer 'p->s1'. : Lines: 255, 256, 258, 260, 261, 264, 265
invalid_memory_access.c ,  267 , Dereferencing NULL pointer 'u->s1'. See line 265 for an earlier location where this can occur: Lines: 255, 256, 258, 260, 261, 264, 265, 267
invalid_memory_access.c ,  270 , Using uninitialized memory '*u'.: Lines: 255, 256, 258, 260, 261, 262, 264, 265, 267, 268, 269, 270
invalid_memory_access.c ,  270 , Using uninitialized memory '*u->s1'.: Lines: 255, 256, 258, 260, 261, 262, 264, 265, 267, 268, 269, 270
invalid_memory_access.c ,  294 , Using uninitialized memory 'ptr1'.: Lines: 286, 287, 288, 289, 291, 289, 291, 289, 293, 294
invalid_memory_access.c ,  371 , Using uninitialized memory 's'.: Lines: 336, 337, 338, 339, 341, 343, 345, 346, 347, 348, 349, 371
invalid_memory_access.c ,  371 , Using uninitialized memory '*s'.: Lines: 336, 337, 338, 339, 341, 343, 345, 346, 347, 348, 349, 371
invalid_memory_access.c ,  371 , Dereferencing NULL pointer 's'. : Lines: 336, 337, 338, 339, 341, 343, 371
invalid_memory_access.c ,  432 , Dereferencing NULL pointer 'invalid_memory_access_013_s_001_s_gbl'. : Lines: 400, 401, 403, 405, 432
invalid_memory_access.c ,  432 , Using uninitialized memory 'invalid_memory_access_013_s_001_s_gbl'.: Lines: 400, 401, 403, 405, 407, 408, 409, 410, 411, 432
invalid_memory_access.c ,  432 , Using uninitialized memory '*invalid_memory_access_013_s_001_s_gbl'.: Lines: 400, 401, 403, 405, 407, 408, 409, 410, 411, 432
invalid_memory_access.c ,  513 , Buffer overrun while writing to 'str_rev':  the writable size is 'i+1' bytes, but 'i' bytes might be written.: Lines: 500, 501, 502, 503, 505, 506, 507, 509, 511, 509, 513
invalid_memory_access.c ,  516 , Using uninitialized memory 'str_rev'.: Lines: 500, 501, 502, 503, 505, 506, 507, 515, 516
invalid_memory_access.c ,  560 , 'invalid_memory_access_016_doubleptr_gbl[i]' could be '0':  this does not adhere to the specification for the function 'strcpy'. : Lines: 553, 554, 556, 557, 559, 560
invalid_memory_access.c ,  559 , Dereferencing NULL pointer 'invalid_memory_access_016_doubleptr_gbl'. : Lines: 553, 554, 556, 557, 559
invalid_memory_access.c ,  583 , Using uninitialized memory '*invalid_memory_access_016_doubleptr_gbl'.: Lines: 573, 574, 579, 581, 583, 584, 581, 583
insign_code.c ,  11 , Inconsistent annotation for 'rand': this instance has no annotations. See c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdlib.h(347). 
invalid_memory_access.c ,  147 , uninitialized local variable 'ptr' used
not_return.c ,  24 , 'not_return_001_func_001': not all control paths return a value
not_return.c ,  50 , 'not_return_002_func_001': not all control paths return a value
not_return.c ,  76 , 'not_return_003_func_001': not all control paths return a value
not_return.c ,  99 , 'not_return_004_func_001': not all control paths return a value
overrun_st.c ,  21 , buffer 'buf' of size 5 bytes will be overrun; 1 bytes will be written starting at offset 5
overrun_st.c ,  32 , buffer 'buf' of size 10 bytes will be overrun; 2 bytes will be written starting at offset 10
overrun_st.c ,  55 , buffer 'buf' of size 20 bytes will be overrun; 4 bytes will be written starting at offset 20
overrun_st.c ,  66 , buffer 'buf' of size 20 bytes will be overrun; 4 bytes will be written starting at offset 20
overrun_st.c ,  706 , buffer 'buf' of size 20 bytes will be overrun; 4 bytes will be written starting at offset 20
overrun_st.c ,  749 , buffer 'buf' of size 5 bytes will be overrun; 1 bytes will be written starting at offset 5
overrun_st.c ,  142 , buffer 'sbuf' of size 60 bytes will be overrun; 4 bytes will be written starting at offset 60
overrun_st.c ,  77 , buffer 'buf' of size 20 bytes will be overrun; 4 bytes will be written starting at offset 20
overrun_st.c ,  88 , buffer 'buf' of size 40 bytes will be overrun; 8 bytes will be written starting at offset 40
return_local.c ,  19 , returning address of local variable or temporary: buf
st_cross_thread_access.c ,  27 , initializer is not a constant
st_cross_thread_access.c ,  28 , initializer is not a constant
st_cross_thread_access.c ,  108 , initializer is not a constant
st_cross_thread_access.c ,  109 , initializer is not a constant
st_cross_thread_access.c ,  202 , initializer is not a constant
st_cross_thread_access.c ,  203 , initializer is not a constant
st_cross_thread_access.c ,  290 , initializer is not a constant
st_cross_thread_access.c ,  291 , initializer is not a constant
st_cross_thread_access.c ,  300 , 'type cast': pointer truncation from 'void *' to 'long'
st_cross_thread_access.c ,  328 , 'type cast': pointer truncation from 'void *' to 'long'
st_cross_thread_access.c ,  364 , initializer is not a constant
st_cross_thread_access.c ,  365 , initializer is not a constant
st_cross_thread_access.c ,  451 , initializer is not a constant
st_cross_thread_access.c ,  452 , initializer is not a constant
st_cross_thread_access.c ,  465 , 'type cast': pointer truncation from 'void *' to 'long'
st_cross_thread_access.c ,  490 , 'type cast': pointer truncation from 'void *' to 'long'
uninit_memory_access.c ,  434 , different array subscripts: 'int (*)[4]' and 'int (*)[0]'
unlock_without_lock.c ,  28 , initializer is not a constant
unlock_without_lock.c ,  84 , initializer is not a constant
unlock_without_lock.c ,  147 , initializer is not a constant
unlock_without_lock.c ,  239 , initializer is not a constant
unlock_without_lock.c ,  240 , initializer is not a constant
unlock_without_lock.c ,  247 , 'type cast': pointer truncation from 'void *' to 'long'
unlock_without_lock.c ,  272 , 'type cast': pointer truncation from 'void *' to 'long'
unlock_without_lock.c ,  308 , initializer is not a constant
unlock_without_lock.c ,  356 , initializer is not a constant
unlock_without_lock.c ,  357 , initializer is not a constant
unlock_without_lock.c ,  365 , 'type cast': pointer truncation from 'void *' to 'long'
unlock_without_lock.c ,  389 , 'type cast': pointer truncation from 'void *' to 'long'
unlock_without_lock.c ,  429 , initializer is not a constant
unlock_without_lock.c ,  430 , initializer is not a constant
unlock_without_lock.c ,  437 , 'type cast': pointer truncation from 'void *' to 'long'
unlock_without_lock.c ,  461 , 'type cast': pointer truncation from 'void *' to 'long'
unlock_without_lock.c ,  500 , initializer is not a constant
unlock_without_lock.c ,  501 , initializer is not a constant
unlock_without_lock.c ,  508 , 'type cast': pointer truncation from 'void *' to 'long'
unlock_without_lock.c ,  532 , 'type cast': pointer truncation from 'void *' to 'long'
zero_division.c ,  13 , Inconsistent annotation for 'rand': this instance has no annotations. See c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\stdlib.h(347). 
zero_division.c ,  236 , Dereferencing NULL pointer 'zero_division_016_gbl_divisor'. : Lines: 235, 236
wrong_arguments_func_pointer.c ,  251 , Using uninitialized memory 'st'.: Lines: 248, 249, 250, 251
wrong_arguments_func_pointer.c ,  337 , Using uninitialized memory 'temp'.: Lines: 330, 331, 332, 333, 335, 336, 337
wrong_arguments_func_pointer.c ,  382 , 'str1' could be '0':  this does not adhere to the specification for the function 'strcpy'. : Lines: 377, 378, 379, 380, 381, 382
wrong_arguments_func_pointer.c ,  434 , Local declaration of 'wrong_arguments_func_pointer_015_dst1_gbl' hides previous declaration at line '17' of 'c:\work\itc-benchmarks\01.w_defects\wrong_arguments_func_pointer.c'.: Lines: 17
wrong_arguments_func_pointer.c ,  451 , Dereferencing NULL pointer 'wrong_arguments_func_pointer_015_dst1_gbl'. : Lines: 447, 448, 449, 451
wrong_arguments_func_pointer.c ,  593 , 'st1' could be '0':  this does not adhere to the specification for the function 'memset'. : Lines: 590, 591, 592, 593
uninit_var.c ,  23 , Using uninitialized memory 'a'.: Lines: 21, 22, 23
uninit_var.c ,  34 , Using uninitialized memory 'buf'.: Lines: 32, 33, 34
uninit_var.c ,  63 , Using uninitialized memory 'dvar'.: Lines: 56, 57, 59, 63
uninit_var.c ,  75 , Using uninitialized memory 'ret'.: Lines: 72, 73, 75
uninit_var.c ,  92 , Using uninitialized memory 'a'.: Lines: 90, 91, 92
uninit_var.c ,  131 , Using uninitialized memory 'data'.: Lines: 127, 128, 129, 131
uninit_var.c ,  142 , String 'ret' might not be zero-terminated.: Lines: 141, 142
uninit_var.c ,  142 , Using uninitialized memory 'ret'.: Lines: 141, 142
uninit_var.c ,  243 , Using uninitialized memory 'val'.: Lines: 242, 243
uninit_pointer.c ,  30 , Using uninitialized memory 'p'.: Lines: 27, 28, 29, 30
uninit_pointer.c ,  41 , Using uninitialized memory 'p'.: Lines: 39, 40, 41
uninit_pointer.c ,  55 , Using possibly uninitialized memory '*pp':  The variable has had its address taken but no assignment to it has been discovered.: Lines: 50, 51, 52, 53, 54, 55
uninit_pointer.c ,  71 , Using uninitialized memory 'p'.: Lines: 69, 70, 71
uninit_pointer.c ,  152 , Using uninitialized memory 'ret'.: Lines: 151, 152
uninit_pointer.c ,  187 , Using uninitialized memory 'buf'.: Lines: 178, 179, 181, 185, 187
uninit_pointer.c ,  187 , String 'buf' might not be zero-terminated.: Lines: 178, 179, 181, 185, 187
uninit_pointer.c ,  268 , Dereferencing NULL pointer 'ptr'. : Lines: 264, 265, 267, 268
uninit_pointer.c ,  277 , Dereferencing NULL pointer 'ptr+i'. See line 268 for an earlier location where this can occur: Lines: 264, 265, 267, 268, 267, 268, 267, 269, 273, 275, 277
uninit_pointer.c ,  358 , Using uninitialized memory 'ptr'.: Lines: 357, 358
uninit_pointer.c ,  383 , Dereferencing NULL pointer 'uninit_pointer_016_gbl_doubleptr'. : Lines: 377, 378, 380, 381, 383
uninit_pointer.c ,  385 , 'uninit_pointer_016_gbl_doubleptr[i]' could be '0':  this does not adhere to the specification for the function 'strcpy'. : Lines: 377, 378, 380, 381, 383, 384, 385
uninit_pointer.c ,  393 , Local declaration of 's' hides previous declaration at line '296' of 'c:\work\itc-benchmarks\01.w_defects\uninit_pointer.c'.: Lines: 296
uninit_pointer.c ,  403 , Using uninitialized memory '*uninit_pointer_016_gbl_doubleptr'.: Lines: 392, 393, 394, 399, 401, 403, 405, 407, 401, 403
uninit_memory_access.c ,  27 , Mismatch on sign: 'unsigned long' passed as _Param_(2) when some signed type is required in call to 'printf'.
uninit_memory_access.c ,  27 , Using uninitialized memory 'a'.: Lines: 24, 25, 26, 27
uninit_memory_access.c ,  54 , Using uninitialized memory 'str2'.: Lines: 50, 51, 52, 54
uninit_memory_access.c ,  54 , String 'str2' might not be zero-terminated.: Lines: 50, 51, 52, 54
uninit_memory_access.c ,  74 , Dereferencing NULL pointer '*ptr'. : Lines: 66, 67, 68, 69, 73, 74
uninit_memory_access.c ,  127 , Using uninitialized memory 'str2'.: Lines: 125, 126, 127
uninit_memory_access.c ,  224 , Dereferencing NULL pointer 'uninit_memory_access_009_doubleptr_gbl'. : Lines: 219, 220, 222, 224
uninit_memory_access.c ,  319 , Using uninitialized memory 'str'.: Lines: 318, 319
uninit_memory_access.c ,  363 , Dereferencing NULL pointer 's1'. : Lines: 359, 360, 362, 363
uninit_memory_access.c ,  369 , 's1' could be '0':  this does not adhere to the specification for the function 'memcpy'. See line 363 for an earlier location where this can occur: Lines: 359, 360, 362, 363, 364, 366, 367, 366, 369
uninit_memory_access.c ,  392 , Dereferencing NULL pointer 'u'. : Lines: 385, 386, 387, 389, 391, 392
uninit_memory_access.c ,  435 , Using uninitialized memory 'arr'.: Lines: 431, 432, 433, 434, 435
uninit_memory_access.c ,  435 , 'p' could be '0':  this does not adhere to the specification for the function 'memcpy'. : Lines: 431, 432, 433, 434, 435
uninit_memory_access.c ,  440 , Dereferencing NULL pointer 'p'. See line 435 for an earlier location where this can occur: Lines: 431, 432, 433, 434, 435, 436, 438, 440
underrun_st.c ,  21 , Index '-1' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
underrun_st.c ,  21 , Reading invalid data from 'buf':  the readable size is '20' bytes, but '-4' bytes may be read.: Lines: 19, 20, 21
underrun_st.c ,  31 , Index '-1' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
underrun_st.c ,  31 , Buffer overrun while writing to 'buf':  the writable size is '20' bytes, but '-4' bytes might be written.: Lines: 30, 31
underrun_st.c ,  42 , Buffer overrun while writing to 'buf':  the writable size is '20' bytes, but '-4' bytes might be written.: Lines: 40, 41, 42
underrun_st.c ,  93 , Index '-1' is out of valid index range '0' to '4' for possibly stack allocated buffer 'buf'.
underrun_st.c ,  124 , Index '-1' is out of valid index range '0' to '4' for non-stack buffer 'underrun_st_009_gbl_buf'.
st_underrun.c ,  80 , Using uninitialized memory 'buf'.: Lines: 79, 80
st_underrun.c ,  115 , Using uninitialized memory 'buf'.: Lines: 114, 115
st_underrun.c ,  150 , Reading invalid data from 's.buf':  the readable size is '10' bytes, but '-1' bytes may be read.: Lines: 150, 152, 153, 160, 150, 152, 153, 160, 150
st_underrun.c ,  160 , Buffer overrun while writing to 's.buf':  the writable size is '10' bytes, but '-1' bytes might be written.: Lines: 150, 152, 153, 160, 150, 152, 153, 160
st_underrun.c ,  204 , Buffer overrun while writing to 's.buf':  the writable size is '10' bytes, but '12' bytes might be written.: Lines: 203, 204
st_overflow.c ,  19 , Function uses '8388608' bytes of stack:  exceeds /analyze:stacksize '16384'.  Consider moving some data to heap.
st_overflow.c ,  47 , Function uses '1048576' bytes of stack:  exceeds /analyze:stacksize '16384'.  Consider moving some data to heap.
st_overflow.c ,  52 , Function uses '1048576' bytes of stack:  exceeds /analyze:stacksize '16384'.  Consider moving some data to heap.
st_overflow.c ,  55 , Using uninitialized memory 's'.: Lines: 54, 55
st_overflow.c ,  74 , Function uses '1312768' bytes of stack:  exceeds /analyze:stacksize '16384'.  Consider moving some data to heap.
st_overflow.c ,  82 , Function uses '788480' bytes of stack:  exceeds /analyze:stacksize '16384'.  Consider moving some data to heap.
st_overflow.c ,  85 , Using uninitialized memory 's'.: Lines: 84, 85
st_overflow.c ,  105 , Function uses '788480' bytes of stack:  exceeds /analyze:stacksize '16384'.  Consider moving some data to heap.
st_overflow.c ,  113 , Function uses '788480' bytes of stack:  exceeds /analyze:stacksize '16384'.  Consider moving some data to heap.
st_overflow.c ,  121 , Function uses '657408' bytes of stack:  exceeds /analyze:stacksize '16384'.  Consider moving some data to heap.
st_overflow.c ,  124 , Using uninitialized memory 's'.: Lines: 123, 124
st_overflow.c ,  139 , Function uses '262148' bytes of stack:  exceeds /analyze:stacksize '16384'.  Consider moving some data to heap.
st_overflow.c ,  151 , Function uses '266240' bytes of stack:  exceeds /analyze:stacksize '16384'.  Consider moving some data to heap.
st_overflow.c ,  155 , Using uninitialized memory 's'.: Lines: 153, 154, 155
st_overflow.c ,  176 , Function uses '1312768' bytes of stack:  exceeds /analyze:stacksize '16384'.  Consider moving some data to heap.
st_overflow.c ,  184 , Function uses '788488' bytes of stack:  exceeds /analyze:stacksize '16384'.  Consider moving some data to heap.
st_overflow.c ,  189 , Using uninitialized memory 's'.: Lines: 186, 187, 188, 189
st_overflow.c ,  209 , Function uses '1050624' bytes of stack:  exceeds /analyze:stacksize '16384'.  Consider moving some data to heap.
st_overflow.c ,  218 , Function uses '1050624' bytes of stack:  exceeds /analyze:stacksize '16384'.  Consider moving some data to heap.
st_overflow.c ,  226 , Function uses '788484' bytes of stack:  exceeds /analyze:stacksize '16384'.  Consider moving some data to heap.
st_overflow.c ,  232 , Using uninitialized memory 's'.: Lines: 228, 229, 230, 232
uninit_memory_access.c ,  54 , uninitialized local variable 'str2' used
uninit_memory_access.c ,  127 , uninitialized local variable 'str2' used
uninit_memory_access.c ,  319 , uninitialized local variable 'str' used
uninit_pointer.c ,  30 , uninitialized local variable 'p' used
uninit_pointer.c ,  41 , uninitialized local variable 'p' used
uninit_pointer.c ,  71 , uninitialized local variable 'p' used
uninit_pointer.c ,  152 , uninitialized local variable 'ret' used
uninit_pointer.c ,  358 , uninitialized local variable 'ptr' used
uninit_var.c ,  23 , uninitialized local variable 'a' used
uninit_var.c ,  75 , uninitialized local variable 'ret' used
uninit_var.c ,  92 , uninitialized local variable 'a' used
uninit_var.c ,  111 , uninitialized local variable 's' used
uninit_var.c ,  131 , uninitialized local variable 'data' used
uninit_var.c ,  243 , uninitialized local variable 'val' used
wrong_arguments_func_pointer.c ,  251 , uninitialized local variable 'st' used
wrong_arguments_func_pointer.c ,  337 , uninitialized local variable 'temp' used
